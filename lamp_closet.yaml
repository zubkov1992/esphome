substitutions:
  devicename: lamp_closet
  platform: ESP8266
  board: nodemcuv2

logger:

<< : !include .common.yaml

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_passwd
  fast_connect: true

light:
  - platform: fastled_clockless
    chipset: WS2812
    pin: D3
    num_leds: 12
    rgb_order: GRB
    name: "Addressable Round Light"
    effects:
      - random:
          name: "Slow Random"
          transition_length: 30s
          update_interval: 30s
      - random:
          name: "Fast Random"
          transition_length: 4s
          update_interval: 5s
      - addressable_scan:
          name: "Scan"
          move_interval: 80ms
          scan_width: 2
      - addressable_fireworks:
      - addressable_flicker:
          name: "Flicker"
          update_interval: 16ms
          intensity: 70%

      - addressable_lambda:
          name: "Fire"
          update_interval: 100ms
          lambda: |-
            int Cooling = 15;
            int Sparking = 90;
            static byte heat[12];
            int cooldown;
            
            // Step 1.  Cool down every cell a little
            for( int i = 0; i < it.size(); i++) {
              cooldown = random(0, ((Cooling * 10) / it.size()) + 2);
              
              if(cooldown>heat[i]) {
                heat[i]=0;
              } else {
                heat[i]=heat[i]-cooldown;
              }
            }
            
            // Step 2.  Heat from each cell drifts 'up' and diffuses a little
            for( int k= it.size() - 1; k >= 2; k--) {
              heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3;
            }
            
            // Step 3.  Randomly ignite new 'sparks' near the bottom
            if( random(255) < Sparking ) {
              int y = random(7);
              heat[y] = heat[y] + random(160,255);
            }
            
            // Step 4.  Convert heat to LED colors
            for( int Pixel = 0; Pixel < it.size(); Pixel++) {
              // Scale 'heat' down from 0-255 to 0-191
              byte t192 = round((heat[Pixel]/255.0)*191);
             
              // calculate ramp up from
              byte heatramp = t192 & 0x3F; // 0..63
              heatramp <<= 2; // scale up to 0..252
             
              // figure out which third of the spectrum we're in:
              //this is where you can reverse the effect by switching the commented out lines in all 3 places.
              if( t192 > 0x80) {                     // hottest
                //it[it.size() - Pixel - 1] = ESPColor(255, 255, heatramp);
                it[Pixel] = ESPColor(255, 255, heatramp);
              } else if( t192 > 0x40 ) {             // middle
                //it[it.size() - Pixel - 1] = ESPColor(255, heatramp, 0);
                it[Pixel] = ESPColor(255, heatramp, 0);
              } else {                               // coolest
                //it[it.size() - Pixel - 1] = ESPColor(heatramp, 0, 0);
                it[Pixel] = ESPColor(heatramp, 0, 0);
              }
            }

      - addressable_lambda:
          name: "Fire Ring"
          update_interval: 5ms
          lambda: |-
            for( int Pixel = 0; Pixel <= it.size(); Pixel++) {
              it[Pixel] = ESPColor(155, 83, 27);
              ESPColor color1;
              uint8_t r1,g1,b1;
              uint8_t r2,g2,b2;
              uint8_t r3,g3,b3;
              int16_t r,g,b;

              color1 = it[Pixel].get();
              //int color2[] = {80,35,0};
              int color2[] = {179, 121, 7};
              
              r1 = (color1[0] ),
              g1 = (color1[1] ),
              b1 = (color1[2] );

              r2 = (color2[0] ),
              g2 = (color2[1] ),
              b2 = (color2[2] );

              // Add Color
              it[Pixel] = ESPColor(constrain(r1+r2, 0, 255), constrain(g1+g2, 0, 255), constrain(b1+b2, 0, 255));
              int rc = random(120);

              // subtract
              
              color2[0] = rc;
              color2[1] = rc/2;
              color2[2] = rc/2;

              r1 = (color1[0] ),
              g1 = (color1[1] ),
              b1 = (color1[2] );

              r2 = (color2[0] ),
              g2 = (color2[1] ),
              b2 = (color2[2] );

              r=(int16_t)r1-(int16_t)r2;
              g=(int16_t)g1-(int16_t)g2;
              b=(int16_t)b1-(int16_t)b2;
              if(r<0) r=0;
              if(g<0) g=0;
              if(b<0) b=0;

              // Substract Color
              it[Pixel] = ESPColor(r, g, b);
            }
            
            delay(random(10,120));

      - addressable_lambda:
          name: "Blue fire"
          update_interval: 5ms
          lambda: |-
            for( int Pixel = 0; Pixel <= it.size(); Pixel++) {
              it[Pixel] = ESPColor(22, 24, 130);
              ESPColor color1;
              uint8_t r1,g1,b1;
              uint8_t r2,g2,b2;
              uint8_t r3,g3,b3;
              int16_t r,g,b;

              color1 = it[Pixel].get();
              //int color2[] = {80,35,0};
              int color2[] = {70, 185, 242};
              
              r1 = (color1[0] ),
              g1 = (color1[1] ),
              b1 = (color1[2] );

              r2 = (color2[0] ),
              g2 = (color2[1] ),
              b2 = (color2[2] );

              // Add Color
              it[Pixel] = ESPColor(constrain(r1+r2, 0, 255), constrain(g1+g2, 0, 255), constrain(b1+b2, 0, 255));
              int rc = random(160);

              // subtract
              
              color2[0] = rc/4;
              color2[1] = rc/4;
              color2[2] = rc;

              r1 = (color1[0] ),
              g1 = (color1[1] ),
              b1 = (color1[2] );

              r2 = (color2[0] ),
              g2 = (color2[1] ),
              b2 = (color2[2] );

              r=(int16_t)r1-(int16_t)r2;
              g=(int16_t)g1-(int16_t)g2;
              b=(int16_t)b1-(int16_t)b2;
              if(r<0) r=0;
              if(g<0) g=0;
              if(b<0) b=0;

              // Substract Color
              it[Pixel] = ESPColor(r, g, b);
            }
            
            delay(random(10,120));
